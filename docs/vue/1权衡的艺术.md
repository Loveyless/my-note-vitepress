## 命令式和声明式

> 从范式上来说 视图层框架分未命令式和声明式

### 命令式

jQ 就是典型的命令式 命令式更加**关注过程**

1. 获取 id 为 app 的 div 标签
2. 设置文本内容为 hello
3. 绑定点击事件
4. 点击时弹出 ok

```js
$("#app")
  .text("hello")
  .on("click", () => {
    alert("ok");
  });
```

### 声明式

vue 就是声明式框架 更加**关注结果**

```html
<div @click="()=>{alert('ok')}">hello</div>
```

我们只需要关注结果，不需要关注过程。

换句话说，是 vue 帮我们封装了过程，**但是 vue 内部实现肯定是命令式的，而暴露给用户的却更加声明式。**

## 性能与可维护性的权衡

先抛出一个结论：**声明式代码的性能不优于命令式代码的性能**，因为 vue 本来就是在命令式的基础上封装出了声明式。

**声明式代码的更新消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**

但是声明式更利于维护，在性能和可维护之间，框架设计者要做的是：**保持可维护性的同时让性能损失最小化。**

## 虚拟 DOM

前面说到，**声明式代码的更新消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。**

因此我们能最小化找到差异的性能消耗，就能让声明式代码的性能无限接近命令式代码的性能。

所谓的虚拟 DOM 就是为了最小化找出差异这一步的性能消耗而出现的

**纯 JavaScript 计算(模板) < 虚拟 DOM < 原生 JavaScript**

1. 纯 JavaScript 计算(模板)

   心智负担中等

   性能差

2. 虚拟 DOM

   心智负担小

   可维护性差

   性能不错

3. 原生 JavaScript

   心智负担大

   可维护性差

   性能高

从三个维度分析：心智负担、可维护性、性能。

原生 DOM 操作心智负担最大，因为要手动创建、删除、修改大量的 DOM 元素。但是性能是最好的，不过为了性能需要承受更多的心智负担。并且可维护性也极差。

innerHTML 来说性能极差，尤其是少量更新，心智负担中等。但是事件的绑定和字符串拼接导致了心智负担也不小。

虚拟 DOM 是声明式，心智负担最小，可维护性强，虽然比不上极致优化的原生，但是也相当不错了。

**思考：有没有办法做到，既能声明式的描述 UI，又具备原生 JavaScript 的性能呢？鱼和熊掌兼得？**

## 运行时和编译时
